# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eWjZQ_N3IhKiv87eBOhDpSdKyP06VRDG
"""

import pandas as pd
from google.colab import drive
!pip install pandasql
from pandasql import sqldf

drive.mount('/content/drive')

path_to_folder = '/content/drive/MyDrive/Case_GlobaS/'

df_accounts = pd.read_json(path_to_folder + "accounts_anonymized.json")
df_cases = pd.read_json(path_to_folder + "support_cases_anonymized.json")

print("\nEstrutura de df_accounts:")
df_accounts.info()

print("\nPrimeiras 5 linhas de df_cases:")
print(df_cases.head())

pysqldf = lambda q: sqldf(q, globals())

# Verificar valores nulos
print("\n1. VALORES NULOS:")
print("Accounts - Valores nulos:")
print(df_accounts.isnull().sum())
print("\nCases - Valores nulos:")
print(df_cases.isnull().sum())

# Verificar duplicatas
print("\n2. DUPLICATAS:")
print(f"Accounts duplicados: {df_accounts.duplicated().sum()}")
print(f"Cases duplicados: {df_cases.duplicated().sum()}")

# Estatísticas descritivas
print("\n3. ESTATÍSTICAS DESCRITIVAS - ACCOUNTS:")
print(df_accounts.describe(include='all'))

print("\n4. ESTATÍSTICAS DESCRITIVAS - CASES:")
print(df_cases.describe(include='all'))

# Distribuição de categorias importantes
print("\n5. DISTRIBUIÇÃO DE CATEGORIAS:")
print("Países dos accounts:")
print(df_accounts['account_country'].value_counts().head(10))

sql_query = """
SELECT
    t1.account_sfid,
    t1.account_country,
    t1.account_industry,
    t2.case_number,
    t2.case_product,
    t2.case_status,
    t2.case_priority,
    t2.case_created_date,
    t2.case_closed_date,
    -- Derivando uma Métrica (KPI): O tempo de resolução em dias
    -- SQLite (usado pelo pandasql) não tem DATEDIFF.
    -- Para calcular a diferença de datas, faremos isso no Pandas após o JOIN.
    -- Vamos primeiro selecionar todos os dados importantes:
    t2.case_sfid
FROM
    df_accounts t1  -- 't1' é o DataFrame df_accounts
INNER JOIN
    df_cases t2     -- 't2' é o DataFrame df_cases
ON
    t1.account_sfid = t2.account_sfid
WHERE
    t2.case_status = 'Closed'; -- Filtra apenas casos fechados para medir o tempo de resolução
"""

df_joined = pysqldf(sql_query)

print("\nDataFrame com Junção (JOIN) e Filtragem concluídas (Primeiras 5 linhas):")
print(df_joined.head())

#Eficiência por indústria
sql_metrics2 = """
SELECT
    t1.account_industry,
    COUNT(t2.case_sfid) as total_cases,
    SUM(CASE WHEN t2.case_priority = 'High' THEN 1 ELSE 0 END) as high_priority_cases,
    AVG((julianday(t2.case_closed_date) - julianday(t2.case_created_date))) as avg_resolution_days
FROM
    df_accounts t1
INNER JOIN
    df_cases t2 ON t1.account_sfid = t2.account_sfid
WHERE
    t2.case_status = 'Closed'
GROUP BY
    t1.account_industry
HAVING
    total_cases > 5  -- Filtra indústrias com pelo menos 5 casos
ORDER BY
    avg_resolution_days DESC
"""

df_metrics2 = pysqldf(sql_metrics2)
print("\nMétricas por Indústria (eficência de resolução):")
print(df_metrics2.head(10))

##Cálculo da Métrica (KPI) - Tempo de Resolução
df_joined['case_created_date'] = pd.to_datetime(df_joined['case_created_date'])
df_joined['case_closed_date'] = pd.to_datetime(df_joined['case_closed_date'])

df_joined['resolution_time_days'] = (
    df_joined['case_closed_date'] - df_joined['case_created_date']
).dt.days

print("\nDataFrame final com a métrica 'resolution_time_days' calculada:")
print(df_joined[['account_country', 'case_product', 'resolution_time_days']].head())

##Criação de Visualizações
import matplotlib.pyplot as plt
import seaborn as sns

# Calcula o tempo médio de resolução por produto
avg_resolution_by_product = df_joined.groupby('case_product')['resolution_time_days'].mean().sort_values(ascending=False)

plt.figure(figsize=(12, 6))
sns.barplot(x=avg_resolution_by_product.index, y=avg_resolution_by_product.values, palette="viridis")
plt.title('Tempo Médio de Resolução de Casos (em dias) por Produto')
plt.xlabel('Produto')
plt.ylabel('Média de Dias para Resolução')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# Visualização 2: Distribuição de casos por prioridade
plt.figure(figsize=(10, 6))
priority_counts = df_cases['case_priority'].value_counts()
plt.pie(priority_counts.values, labels=priority_counts.index, autopct='%1.1f%%', colors=['#ff9999','#66b3ff','#99ff99'])
plt.title('Distribuição de Casos por Prioridade')
plt.show()

# Visualização 3: Top 10 países com mais casos
plt.figure(figsize=(12, 6))
country_cases = df_joined['account_country'].value_counts().head(10)
sns.barplot(x=country_cases.values, y=country_cases.index, palette="rocket")
plt.title('Top 10 Países com Mais Casos de Suporte')
plt.xlabel('Número de Casos')
plt.ylabel('País')
plt.tight_layout()
plt.show()

# Visualização 4: Tempo de resolução por prioridade
plt.figure(figsize=(10, 6))
sns.boxplot(data=df_joined, x='case_priority', y='resolution_time_days', palette="Set2")
plt.title('Tempo de Resolução por Prioridade do Caso')
plt.xlabel('Prioridade')
plt.ylabel('Dias para Resolução')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Cálculos para insights

# Insight 1: Produto com maior tempo de resolução
slowest_product = df_joined.groupby('case_product')['resolution_time_days'].mean().idxmax()
slowest_time = df_joined.groupby('case_product')['resolution_time_days'].mean().max()

print(f"1. PRODUTO COM MAIOR TEMPO DE RESOLUÇÃO:")
print(f"   • {slowest_product}: {slowest_time:.1f} dias em média")
print(f"   • Insight: Este produto pode ter problemas complexos ou falta de documentação adequada")

# Insight 2: País com casos mais demorados
slowest_country = df_joined.groupby('account_country')['resolution_time_days'].mean().idxmax()
slowest_country_time = df_joined.groupby('account_country')['resolution_time_days'].mean().max()

print(f"\n2. PAÍS COM CASOS MAIS DEMORADOS:")
print(f"   • {slowest_country}: {slowest_country_time:.1f} dias em média")
print(f"   • Insight: Pode haver barreiras de idioma, fuso horário ou falta de recursos locais")

# Insight 3: Comparação de eficiência por prioridade
priority_efficiency = df_joined.groupby('case_priority')['resolution_time_days'].mean()
print(f"\n3. EFICIÊNCIA POR PRIORIDADE:")
for priority, time in priority_efficiency.items():
    print(f"   • {priority}: {time:.1f} dias")

# Insight 4: Volume vs. Tempo de Resolução
case_volume_by_product = df_joined['case_product'].value_counts()
resolution_by_product = df_joined.groupby('case_product')['resolution_time_days'].mean()

print(f"\n4. RELAÇÃO ENTRE VOLUME E TEMPO DE RESOLUÇÃO:")
for product in case_volume_by_product.index[:5]:
    volume = case_volume_by_product[product]
    resolution = resolution_by_product[product]
    print(f"   • {product}: {volume} casos, {resolution:.1f} dias médios")